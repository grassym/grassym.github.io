<html>
<head>
	<title>feel the power of shaders</title>
</head>
<body>
<h1><b>Storing complex numbers in 8-bit RGBA texture</b></h1><br>
The problem is: FFT on shader doesn't work well because of shader specific. :)
Complex image is stored in texture, and is passed to fragment shader as <code>uniform sampler2D</code>. 
Fragment shader receives current "color", which actually is a complex number, performs some operations on it, such as addition and multiplication, and writes result as output "color".


<br><br>The facts I use as axioms:<br>
<ol>
<li> RGBA texture holds <code>float</code> numbers of <code>lowp</code> in range <code>[0.0 .. 1.0]</code>, which is passed to output texture as <code>[0 .. 255]</code> pixel value</code>.</li>
<li> Complex number is in range <code>[-255 .. 255]</code> => <code>[-1.0 .. 1.0]</code>, thus it can not be stored without <b>packing</b>. </li>
</ol>
<br>
The facts I use as bottlenecks:<br>
<ol>
<li><code>lowp</code> means precision 2<sup>-8</sup>, but what does that actually mean? How float is stored in 8 bits?</li>
</ol>
I've tried a few approaches, one of them based on <code>pow2/exp2</code> calculation, which led to losses in precision.

So, the first task will be <b>to learn how float is stored in 8-bits</b>.

<br>I found <a href="https://www.opengl.org/wiki/Normalized_Integer">opengl article about <b>Normalized Integers</b></a>. They write that fragment shader maps <code>int [0, MAX]</code> to <code>float [0, 1.0]</code> linearly, using the following simple equation:
<code><i>float</i> = <i>int</i> / MAX</code>; 
<br>And it uses <b>rounding</b>. So, if the value was 0.245, result will be 62, and if 0.246, result will be 63 (<i>prooved</i>).

<br>The first stage will be to <code>stage0-validate</code> each decode/encode function pair: 
<pre>
<b>exp2/pow2 idea:</b>
float decodeFromMyFloatFormat(vec2 c)
{
    float sgn = (c.x-0.5)*2.0;
    float val = exp2(c.y*3.0) - 1.0;
    return val*sgn;
}

vec2 encodeToMyFloatFormat(float c)
{
    float sgn = step(0.0, c); // 0.0 if c < 0.0, else 1.0
    c = abs(c);
    return vec2(sgn, log2(c+1.0)/3.0);
}
<b>168 => 167.7, bad</b>
</pre>
<pre>
<b>haar idea:</b>
vec4 encode(vec2 cpx)
{
    float re = cpx.x, im = cpx.y;
    float sum = (re + im);
    float dif = (re - im);
    float sign_sum = step(0.0, sum);
    float sign_dif = step(0.0, dif);
    sum = abs(sum);
    dif = abs(dif);
    return vec4(sum, dif, sign_sum, sign_dif);
}

vec2 decode(vec4 cpx)
{
    float sign_sum = (cpx.z - 0.5)*2.0;
    float sign_dif = (cpx.w - 0.5)*2.0;
    float sum = cpx.x * sign_sum, dif = cpx.y * sign_dif;
    float re = (sum + dif)/2.0;
    float im = sum - re;
    return vec2(re, im);
}
<b>168 => 168, good. This is stage0. What about cooley-tukey loop?</b>
</pre>
<br>
Going deeper: 
<ol>
	<li>fragment shader receives 1.0 1.0 as left corner pixel's COORDINATES???</li>
	<li><code>mod</code> function for mod(0.0, 1.0) works incorrect??? </li>
</ol>

As <a href="https://www.opengl.org/sdk/docs/man/html/mod.xhtml">documentation on mod function</a> says, <br>
<code>mod(x,y) = x - y * floor(x/y)</code>.
<pre>
Thus, when I call mod(0.0,1.0), it should behave like that:
mod(0.0,1.0) = 0.0 - 1.0 * floor(0.0/1.0) = 0.0 - 1.0 * floor(0.0) = 0.0 - 1.0*0.0 = 0.0.
But <code>floor</code> func doesn't work well for values like 2<sup>-8</sup>, so I need to call floor(x+1.0/255.0) instead of floor(x) or even floor(x+1.0/512.0)  
</pre>
</body>
</html>